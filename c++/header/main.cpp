//#include <iostream>
#include "B.hpp"
#include "A.hpp"
#include "C.hpp"

//using namespace std;
/**
 * 只有被调用时才汇编!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 * 预编译后，编译器只翻译源文件中调用过的内联函数,类成员函数，自定义的类构造函数的声明。
 * 没有被调用的不会被翻译，默认构造函数不会被翻译成汇编。
 * 
 * 汇编文件，目标文件中只出现被调用过的内联函数，内联成员函数的函数体。
 * 
 * 问，什么是link?
 * 就是通过声明找定义的过程!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 源文件之间的实际通信链接是通过link完成
 * 
 * 内联函数：
 * 只有定义没有声明，只能调用函数体定义，如果当前源文件中没有该函数体定义，就报错。所以内联函数需定义在调用的源文件里。
 * 换句话说，内联函数在link前的汇编和目标文件就可以找到函数体。　－》　内联函数可见。 可见到真正的函数体而不只是声明。                           
 * 
 * 普通函数：是通过声明调用，汇编中只有ｃａｌｌ 函数名。函数体定义通过link时才找到。
 * 
 * 111.在源文件中定义的内联函数在.i预编译文件中有，但是不会被翻译汇编，在.s .o文件找不到对应的代码。!!!!!!!!
 * 222.只有被调用时才会被汇编城二进制码。
 * 
 * 1.只有内联函数且被源文件调用，才会被编译成汇编语言，并汇编加到目标文件中。
 * 2.内联函数体块，被包含在多个目标文件中，最后lｉｎｋ时会优化，会删除其他副本，保证最后的执行文件中只有一份内联函数代码快。
 * 
 *
 * 
 * 问，为什么内联函数定义必须写在头文件里？
 * 定义在源文件中，且没有在当前源文件被调用，就不会被汇编，也就没有没有二进制码
 * link时，其他源文件找不到二进制的函数体，报错。
 * 头文件里的内联函数如果没被调用过，也不会被汇编成二进制码。
 * 
 * 问，头文件里可以都写内联函数吗？
 * 可以，但会减低前编译速度，因为多次展开，增加最后优化合并时间
 * 函数体长的内联函数不会被编译器内联，是否内联由编译器决定。
 * 
 * 问，类定义为什么可以放到头文件里？
 * 类定义中就是＝=多个函数的声明和内联函数的集合,所以类定义可以放在头文件中多次被包含多次定义
 * 类在头文件被多个源文件包含时，被包含的就是成员函数的声明和内联函数。
 * 如
 * class BB //ZN2BB
{
public:
     int aa = 2;
     int bb = 10;
public:
    BB() = default;

    BB(int x, int y); //call _ZN2BBC1Eii　汇编代码的构造函数
    BB( int& x): aa(x){
        //内联构造函数
    }
    ~BB() = default;

    void test_classB(int a, int b){
        int c = a * b + aa + bb; //内联函数块
    }
     //call _ZN2BB11test_classBEii
};
 */ 
/**
 *#ifndef 只保证同一个源文件里的包含内容是唯一不重复，即预编译后src.i文件中头文件的内容是唯一不重复的
 * 但是，一个#ifndef头文件会被多个源文件包含。 
 * 
 * 普通函数定义在＃ifnedf的头文件中,只是编译不链接文件，不会报错。当link时发现多次定义报错
 */
int main(){

   const int a = 11, b = 20;
   int out;
   if (sub( b, a, out) )
        print_out(a,out);
//	cout << "-------start-----" << endl;
	if ( sub(a, b, out) )
		print_out(a,out);
//		cout << out << endl;
        
    
//		cout << out << endl;
    test_linie(a, b);  

    //BB b_class;//默认构造函数不会被翻译成汇编，不会出现在汇编文件里，默认构造函数相当于一个指针
    int x = 10;
    BB b_class(x); //call 内联　_ZN2BBC2ERi　定义展开在本目标文件里    
    int c = b_class.aa;
    int d = b_class.bb;
    b_class.test_classB(a,b);//call	_ZN2BB11test_classBEii
	return 0;
}